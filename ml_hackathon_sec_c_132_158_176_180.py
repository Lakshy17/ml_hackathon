# -*- coding: utf-8 -*-
"""ML_Hackathon_Sec_C_132_158_176_180.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1OT5RGMbfGwSvwy4eYIKiE6Zr8Tn0ikEX
"""

import random
import time
from collections import Counter, defaultdict
import numpy as np

TRAIN_PATH = "corpus.txt"
TEST_PATH = "test.txt"
MIN_LEN, MAX_LEN = 3, 12
WARMUP_GAMES = 4000  # Increased warmup for better cache
PRUNE_TOP_K = 300    # Reduced pruning for sharper candidate focus
MAX_WRONG = 10
LEARNING_RATE = 0.2
GAMMA = 0.9

def load_words(filename):
    try:
        with open(filename, 'r') as f:
            return [w.strip().upper() for w in f if w.strip()]
    except:
        return []

class SmartHangmanAgentV8_4:
    def __init__(self, corpus):
        self.corpus = corpus
        self.vowels = set("AEIOU")
        self.english_freq = "ETAOINSHRDLUCMFYWGPBVKXQJZ"
        self.memory = defaultdict(lambda: 1.0)
        self.q_values = defaultdict(float)
        self.pattern_cache = {}
        self.length_models = {}
        self.transition_probs = defaultdict(lambda: defaultdict(float))
        self.epsilon = 0.95
        self.epsilon_min = 0.05
        self.epsilon_decay = 0.9998
        self._build_models()

    def _build_models(self):
        for L in range(MIN_LEN, MAX_LEN + 1):
            words = [w for w in self.corpus if len(w) == L]
            if not words:
                continue
            global_freq = Counter()
            pos_freq = defaultdict(Counter)
            for w in words:
                global_freq.update(w)
                for i, c in enumerate(w):
                    pos_freq[i][c] += 1
                    if i < len(w) - 1:
                        self.transition_probs[w[i]][w[i + 1]] += 1
            total = sum(global_freq.values()) or 1
            global_probs = {c: global_freq[c] / total for c in global_freq}
            self.length_models[L] = {"words": words, "global": global_probs, "pos": pos_freq}

        for a in self.transition_probs:
            total = sum(self.transition_probs[a].values()) or 1
            for b in self.transition_probs[a]:
                self.transition_probs[a][b] /= total

    def filter_candidates(self, pattern, guessed):
        L = len(pattern)
        if L not in self.length_models:
            return []
        candidates = []
        for w in self.length_models[L]["words"]:
            if any((c in guessed and c not in pattern) for c in w):
                continue
            if all(p == "_" or p == c for p, c in zip(pattern, w)):
                candidates.append(w)
        return candidates

    def hmm_predict(self, pattern, guessed):
        scores = defaultdict(float)
        known = [c for c in pattern if c != "_"]
        if not known:
            return {}
        for i, ch in enumerate(pattern):
            if ch != "_":
                for nxt, p in self.transition_probs[ch].items():
                    if nxt not in guessed:
                        scores[nxt] += p * (1.0 / (i + 1))
        total = sum(scores.values()) or 1
        return {c: scores[c] / total for c in scores}

    def score_letters(self, L, candidates, guessed, pattern):
        if not candidates:
            return {}
        candidates = candidates[:PRUNE_TOP_K]
        letter_counts = Counter()
        pos_freq = self.length_models[L]["pos"]
        for w in candidates:
            for i, c in enumerate(w):
                if pattern[i] == "_" and c not in guessed:
                    weight = 1.0 + (pos_freq[i][c] / max(1, len(candidates))) * 1.2  # Increased weight
                    letter_counts[c] += weight
        total = sum(letter_counts.values()) or 1
        return {c: letter_counts[c] / total for c in letter_counts}

    def get_guess(self, pattern, guessed, wrong_guesses, last_guess=None):
        pattern_str = "".join(pattern) if isinstance(pattern, list) else pattern
        if pattern_str in self.pattern_cache:
            for l in self.pattern_cache[pattern_str]:
                if l not in guessed:
                    return l
        L = len(pattern_str)
        candidates = self.filter_candidates(pattern_str, guessed)
        freq_scores = self.score_letters(L, candidates, guessed, pattern_str)
        hmm_scores = self.hmm_predict(pattern_str, guessed)
        unguessed = [c for c in "ABCDEFGHIJKLMNOPQRSTUVWXYZ" if c not in guessed]
        final_scores = {}

        for c in unguessed:
            base_prior = (27 - self.english_freq.index(c)) / 27 if c in self.english_freq else 0.02
            freq = freq_scores.get(c, 0)
            hmm = hmm_scores.get(c, 0)
            q_val = self.q_values[c]
            vowel_bonus = 0.05 if (pattern_str.count("_") > len(pattern_str) * 0.6 and c in self.vowels) else 0
            explore = random.uniform(0, 0.002)
            final_scores[c] = (
                0.50 * freq +
                0.35 * hmm +
                0.05 * base_prior +
                0.05 * q_val +
                vowel_bonus +
                explore
            )
        guess = max(final_scores, key=final_scores.get)
        return guess

    def update_q(self, letter, reward):
        old_q = self.q_values[letter]
        max_future_q = max(self.q_values.values() or [0])
        self.q_values[letter] = old_q + LEARNING_RATE * (reward + GAMMA * max_future_q - old_q)

    def reinforce(self, letter, success=True):
        reward = 1 if success else -1.5  # harsher penalty for failure
        self.update_q(letter, reward)
        if success:
            self.memory[letter] = min(self.memory[letter] * 1.10 + 0.03, 3.0)  # stronger reinforcement
        else:
            self.memory[letter] = max(self.memory[letter] * 0.93, 0.2)  # slower decay

    def cache_pattern_from_game(self, pattern, guessed_seq, word):
        key = "".join(pattern)
        correct_seq = [g for g in guessed_seq if g in word]
        if not correct_seq:
            return
        if key not in self.pattern_cache or len(correct_seq) > len(self.pattern_cache[key]):
            self.pattern_cache[key] = correct_seq[:]

    def prune_cache(self, max_cache_size=3000):
        if len(self.pattern_cache) <= max_cache_size:
            return
        # Prune least recently used or smallest length entries, simplistic example:
        sorted_items = sorted(self.pattern_cache.items(), key=lambda x: len(x[1]), reverse=True)
        self.pattern_cache = dict(sorted_items[:max_cache_size])

class HangmanEvaluator:
    def __init__(self, agent, train_words, test_words):
        self.agent = agent
        self.train_words = train_words
        self.test_words = test_words

    def play_game(self, word, allow_caching=True):
        pattern = ["_"] * len(word)
        guessed = []
        wrong = 0
        repeated = 0
        while "_" in pattern and wrong < MAX_WRONG:
            guess = self.agent.get_guess(pattern, guessed, wrong)
            if guess in guessed:
                repeated += 1
                continue
            guessed.append(guess)
            if guess in word:
                for i, c in enumerate(word):
                    if c == guess:
                        pattern[i] = guess
                self.agent.reinforce(guess, True)
            else:
                wrong += 1
                self.agent.reinforce(guess, False)
        won = "_" not in pattern
        if won and allow_caching:
            self.agent.cache_pattern_from_game(pattern, guessed, word)
        return won, wrong, repeated

    def warmup(self, warmup_games=WARMUP_GAMES):
        if warmup_games <= 0:
            return
        print(f"ðŸ” Warmup ({warmup_games} self-play games)")
        for i in range(warmup_games):
            w = random.choice(self.train_words)
            self.play_game(w, allow_caching=True)
            self.agent.prune_cache()
            self.agent.epsilon = max(self.agent.epsilon_min, self.agent.epsilon * self.agent.epsilon_decay)
            if (i + 1) % 200 == 0:
                print(f"Warmup {i+1}/{warmup_games}: Cache {len(self.agent.pattern_cache)} Size, Epsilon {self.agent.epsilon:.3f}")

    def evaluate(self, num_games=2000):
        start = time.time()
        wins, wrong_total, repeated_total = 0, 0, 0
        for i in range(num_games):
            w = random.choice(self.test_words)
            won, wrong, repeated = self.play_game(w, allow_caching=False)
            wins += won
            wrong_total += wrong
            repeated_total += repeated
            if (i + 1) % 100 == 0:
                print(f"Played {i+1}/{num_games} games. Cache size: {len(self.agent.pattern_cache)}")
        success_rate = wins / num_games
        final_score = (success_rate * 2000) - (wrong_total * 5) - (repeated_total * 2)
        elapsed = time.time() - start
        print("\n=== Final Report ===")
        print(f"Success Rate: {success_rate*100:.2f}%")
        print(f"Total Wrong Guesses: {wrong_total}")
        print(f"Total Repeated Guesses: {repeated_total}")
        print(f"Final Score: {final_score/2:.2f}")
        print(f"Elapsed Time: {elapsed:.2f}s")
        return success_rate, final_score

if __name__ == "__main__":
    train_corpus = load_words(TRAIN_PATH)
    test_corpus = load_words(TEST_PATH)

    agent = SmartHangmanAgentV8_4(train_corpus)
    evaluator = HangmanEvaluator(agent, train_corpus, test_corpus)

    evaluator.warmup(WARMUP_GAMES)
    success, score = evaluator.evaluate(2000)

    print("\nUse 'WARMUP_GAMES' and pruning settings to optimize balance of runtime and accuracy.")